# Property Price Prediction based on Inflation Forecast

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression, Lasso, Ridge, ElasticNet
from sklearn.model_selection import train_test_split
from sklearn.ensemble import StackingRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from sklearn.preprocessing import StandardScaler
from xgboost import XGBRegressor
import matplotlib.pyplot as plt
import seaborn as sns
from mpl_toolkits.mplot3d import Axes3D


file_path = "C:\\Users\\adity\\pythonlang\\pythonproj.xlsx"
try:
    df = pd.read_excel(file_path)
    print("File Loaded Successfully!\n")
    print(df.iloc[:20,:])
except Exception as e:
    print(f"Error loading file: {e}")
    exit()

def total_price(df):
    required_area = int(input("Enter the required area in sqft: "))
    if 'AveragePrice' in df.columns:
        df['price_per_sqft'] = df['AveragePrice']
        df['total_price'] = df['price_per_sqft'] * required_area
        return df[['Areas', 'total_price']].groupby('Areas').mean().sort_values(by='total_price', ascending=False)
    else:
        print("missing_data")
        return df
def calc_price_stats(df):
    if 'AveragePrice' in df.columns:
        area_stats = df.groupby('Areas')['AveragePrice'].agg(['mean', 'median', 'std', 'min', 'max'])
        area_stats['coef_var'] = (area_stats['std'] / area_stats['mean']) * 100
        return area_stats.sort_values('mean', ascending=False)
    return None

gdp = [7.5, 7.1, 6.8, 6.1, 4.2, 7.3, 8.7, 6.8, 6.0]
ur = [5.0, 4.9, 4.7, 4.5, 6.1, 7.0, 6.6, 6.3, 5.9]
money = [10.5, 11.2, 12, 12.8, 13.8, 14.5, 16.3, 17.5, 18.0]
inflation_rate = [5.5, 5.1, 4.8, 4.6, 4.8, 6.6, 5.3, 6.8, 6.0]

indf = pd.DataFrame({"gdp growth": gdp, "unemployment": ur, "money_supp": money})
print(indf)
X = StandardScaler().fit_transform(indf)
y = inflation_rate

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
base_lasso = Lasso(alpha=0.1, random_state=42, max_iter=5000)
base_xgb = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
base_ridge = Ridge(alpha=1.0, random_state=42)
base_gbm = GradientBoostingRegressor(n_estimators=50, learning_rate=0.1, random_state=42)

stacked_model = StackingRegressor(
    estimators=[
        ('lasso', base_lasso),
        ('xgb', base_xgb),
        ('ridge', base_ridge),
        ('gbm', base_gbm)
    ],
    final_estimator=ElasticNet(alpha=0.1, l1_ratio=0.5, random_state=42, max_iter=5000),
    cv=3
)

stacked_model.fit(X_train, y_train)
y_pred = stacked_model.predict(X_test)
y_train_pred = stacked_model.predict(X_train)

r2_test = r2_score(y_test, y_pred)
mse_test = mean_squared_error(y_test, y_pred)
mae_test = mean_absolute_error(y_test, y_pred)
rmse_test = np.sqrt(mse_test)

r2_train = r2_score(y_train, y_train_pred)
mse_train = mean_squared_error(y_train, y_train_pred)

print("\n=== Model Performance Metrics ===")
print(f"Train R2 Score: {r2_train:.4f}")
print(f"Test R2 Score: {r2_test:.4f}")
print(f"Test MSE: {mse_test:.4f}")
print(f"Test RMSE: {rmse_test:.4f}")
print(f"Test MAE: {mae_test:.4f}")


def plot_inflation():
    plt.figure(figsize=(6, 4))
    sns.lineplot(x=range(len(y_test)), y=y_test, label='Actual', marker='o')
    sns.lineplot(x=range(len(y_pred)), y=y_pred, label='Predicted', marker='D')
    plt.title("Inflation Rate Prediction")
    plt.xlabel("Index")
    plt.ylabel("Inflation Rate")
    plt.legend()
    plt.tight_layout()
    plt.show()

plot_inflation()

def Price_vs_inflation():
    Prices = np.linspace(50, 100, len(y_pred))
    Time = np.linspace(5, 10, len(y_pred))
    Time_mesh, Prices_mesh = np.meshgrid(Time, Prices)
    Inflation_mesh = np.tile(y_pred, (len(Prices), 1)).T

    fig = plt.figure(figsize=(8, 6))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(Prices_mesh, Time_mesh, Inflation_mesh, cmap='viridis')
    ax.set_xlabel('Average Price (Lakhs)')
    ax.set_ylabel('Years')
    ax.set_zlabel('Predicted Inflation Rate')
    plt.title('Inflated Price')
    plt.tight_layout()
    plt.show()

print()
print("Future Price Prediction")
user_loc =input("Enter the location ")
user_area=int(input("Enter desired area"))
price=df.loc[df['Areas'] == user_loc, 'AveragePrice'].iloc[0]
area_price = price*user_area
print(user_loc,user_area,area_price)
avg_inflation = np.mean(y_pred) / 100
GrowthRate = 0.08
real_growth = GrowthRate - avg_inflation

for years in [5, 7, 10]:
    future_price = area_price * ((1 + real_growth) ** years)
    print(f"Price after {years} years: â‚¹{round(future_price):,}")

def plot_price_difference():
    years = [5, 7, 10]
    current_price = area_price
    avg_inflation = np.mean(y_pred) / 100
    GrowthRate = 0.08
    real_growth = GrowthRate- avg_inflation

    future_prices = [current_price * ((1 + real_growth) ** yr) for yr in years]

    plt.figure(figsize=(7, 4))
    plt.bar([f"{yr} yrs (Now)" for yr in years], [current_price]*len(years), label='Current Price', alpha=0.6)
    plt.bar([f"{yr} yrs (Future)" for yr in years], future_prices, label='Predicted Price', alpha=0.8)
    plt.ylabel("Price (INR)")
    plt.title("Before vs After Property Price")
    plt.xticks(rotation=45)
    plt.legend()
    plt.tight_layout()
    plt.show()

plot_price_difference()

def plot_area_price_heatmap(df):
    area_price_df = df[['Areas', 'AveragePrice']].groupby('Areas').mean()
    area_price_df = area_price_df.sort_values('AveragePrice', ascending=False)
    plt.figure(figsize=(80, 6))
    sns.heatmap(area_price_df.T, annot=True, fmt=".0f", cmap="YlOrRd",cbar=True, linewidths=0.8)
    plt.title("Average Total Price by Area")
    plt.xticks(rotation=45, ha='right', fontsize=10)
    plt.tight_layout()
    plt.show()

plot_area_price_heatmap(df)
Price_vs_inflation()

def plot_top_areas(df, top_n=15):
    area_stats = df.groupby('Areas')['AveragePrice'].agg(['mean', 'count']).reset_index()
    area_stats = area_stats.nlargest(top_n, 'mean')
    
    fig, axes = plt.subplots(1, 2, figsize=(16, 6))
    
    sns.barplot(data=area_stats, y='Areas', x='mean', ax=axes[0], palette='rocket')
    axes[0].set_xlabel('Average Price per Sqft (INR)', fontsize=11)
    axes[0].set_ylabel('Areas', fontsize=11)
    axes[0].set_title(f'Top {top_n} Most Expensive Areas', fontsize=12, fontweight='bold')
    axes[0].grid(axis='x', alpha=0.3)
    
    sns.scatterplot(data=area_stats, x='mean', y='count', size='mean', 
                    sizes=(50, 500), alpha=0.6, ax=axes[1], legend=False)
    axes[1].set_xlabel('Average Price per Sqft (INR)', fontsize=11)
    axes[1].set_ylabel('Number of Properties', fontsize=11)
    axes[1].set_title('Price vs Property Count', fontsize=12, fontweight='bold')
    axes[1].grid(alpha=0.3)
    
    plt.tight_layout()
    plt.show()

import pickle

with open('stacked_model.pkl', 'wb') as f:
    pickle.dump(stacked_model, f)
with open('y_pred.pkl', 'wb') as f:
    pickle.dump(y_pred, f)
with open('y_test.pkl', 'wb') as f:
    pickle.dump(y_test, f)
with open('metrics.pkl', 'wb') as f:
    pickle.dump({
        'r2_train': r2_train,
        'r2_test': r2_test,
        'mse_test': mse_test,
        'rmse_test': rmse_test,
        'mae_test': mae_test
    }, f)
